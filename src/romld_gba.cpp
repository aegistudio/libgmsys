/**
 * romld_gba.cpp - GBA (GameBoy Advanced) ROM loader 
 * for GMSYS-generated ELF format
 * @author Haoran Luo
 *
 * The ROM loader that converts the ELF file generated
 * via gmsys-gbald command and composed with specific
 * sections and symbols into an actual working GBA rom.
 */
#include <bfd.h>
#include <cstdio>
#include <iostream>
#include <cstdlib>
#include <errno.h>
#include <string>
#include <vector>
#include <map>
#include <functional>

// Define the software buffer to hold the processed code.
typedef std::vector<char> Buffer;

// Symbol processor for processing the symbol table and extract
// useful information for linking.
class BfdSymbolConsumer {
public:
	virtual void process(asymbol*) = 0;
};

// Implementation for symbol processor that retrieve a named symbol
// for its in-section offset, the symbol should be in the specified
// section which retrieved earlier.
class BfdOffsetConsumer : public BfdSymbolConsumer {
	asection* section;
public:
	int offset;

	BfdOffsetConsumer(asection* _section):
		section(_section), offset(0) {}

	void process(asymbol* symbol) {
		if(symbol -> section == section) offset = symbol -> value;
	}
};

// The argv[0] while running this program.
static char* argv0;

// Display error message and show the usage of this command.
// The function will directly terminate this program via exit().
void errorUsage(int code, const char* message, const char* brief = nullptr) {
	// Construct the error message text and use perror.
	std::string errorMessage("Error: ");
	errorMessage += message;
	if(brief == nullptr) {
		errno = code;
		perror(errorMessage.c_str());
	}
	else std::cerr << errorMessage << ": " << brief << std::endl;

	// Print out the program usage.
	std::cerr << "Usage: " << argv0 << 
		" <elfName> [gbaName] " << std::endl;
	exit(code);
}

// Message shown while the file does not meet specification.
const char* eDisqualified = "Not ELF generated by GMSYS";
const int ecDisqualified = -105;

// Message shown while the export file has no more space.
const char* eInsufficientSpace = "Space not allocatable in exported file";
const int ecInsufficientSpace = -103;

// Write out a word to the buffer in little-endian order.
void writeWord(Buffer& outputBuffer, int address, int data) {
	outputBuffer[address + 0] = (char)((data >>  0) & 0x0ff);
	outputBuffer[address + 1] = (char)((data >>  8) & 0x0ff);
	outputBuffer[address + 2] = (char)((data >> 16) & 0x0ff);
	outputBuffer[address + 3] = (char)((data >> 24) & 0x0ff);
}

// Allocate more space in the buffer. The space should be multiple
// of 32-byte so that the BIOS fast copy command could be used
// easily and improve the efficiency.
void allocateMore(Buffer& outputBuffer, int size) {
	int newSize = outputBuffer.size() + size;
	newSize = (newSize + 31) / 32;
	newSize = newSize * 32;
	outputBuffer.resize(newSize);
}

// Allocate space for loadable sections (a .*.text section with a .*.data section)
// and write out the address and size in exported ROM. The total size of the section
// will be checked and report error while exceeding the section limit.
void appendLoadableSections(bfd* fd, Buffer& outputBuffer, 
	BfdOffsetConsumer& wramAddress, BfdOffsetConsumer& wramSize,
	asection* wramText, asection* wramData, int bufferVma, int wramSizeLimit) {

	if(wramText == NULL && wramData == NULL) return;

	// Retrieve the starting address of current sections, and write
	// the address to the ROM header.
	size_t bufferSize = outputBuffer.size();
	writeWord(outputBuffer, wramAddress.offset, bufferVma + bufferSize);

	// Find out the number of bytes to write, and allocate space.
	int wramAllocSize = 0;
	if(wramText != NULL) wramAllocSize += wramText -> size;
	if(wramData != NULL) wramAllocSize += wramData -> size;
	allocateMore(outputBuffer, wramAllocSize);
	wramAllocSize = outputBuffer.size() - bufferSize;

	// Ensure the size of buffer do not exceed the size limit.
	if(wramAllocSize > wramSizeLimit) errorUsage(ecInsufficientSpace, 
		"The section size of exceeds the limit allocatable of this "
		"section, try to optimize your code", eInsufficientSpace);

	// Write out the size in word for the ROM loader.
	int wramWordAmount = wramAllocSize / 4;
	writeWord(outputBuffer, wramSize.offset, wramWordAmount);

	// Write out the buffer by the offset.
	int pointer = bufferSize;
	if(wramText != NULL) {
		bfd_get_section_contents(fd, wramText, 
			&outputBuffer[pointer], 0, wramText -> size);
		pointer += wramText -> size;
	}
	if(wramData != NULL) {
		bfd_get_section_contents(fd, wramData, 
			&outputBuffer[pointer], 0, wramData -> size);
		pointer += wramData -> size;
	}
};

// The main function of the ROM converter.
int main(int argc, char** argv) {
	argv0 = argv[0];

	// Validate and process the argument list.
	if(argc <= 1) errorUsage(EINVAL, "Compiled ELF file should be specified");
	std::string elfFileName = argv[1];
	std::string romFileName = elfFileName + ".gba";
	if(argc >= 3) romFileName = argv[2];

	// Initialize Binary File Descriptor and the object file.
	bfd_init();
	bfd* elffd = bfd_openr(elfFileName.c_str(), NULL);
	if(elffd == NULL) errorUsage(EIO, "Cannot open specified ELF file");
	else if(!bfd_check_format(elffd, bfd_object)) 
		errorUsage(EBADF, "Specified file is not an ELF file");

	// Retrieve potential sections from the file, and ensure that
	// the file could be exported correctly.
	asection* rom = bfd_get_section_by_name(elffd, ".rom");
	asection* wramSlowText = bfd_get_section_by_name(elffd, ".wram.text");
	asection* wramSlowData = bfd_get_section_by_name(elffd, ".wram.data");
	asection* wramFastText = bfd_get_section_by_name(elffd, ".fastwram.text");
	asection* wramFastData = bfd_get_section_by_name(elffd, ".fastwram.data");

	// Ensure the file has a .rom section with updatable symbols.
	// And copy the data from the text to the output buffer.
	if(rom == NULL) errorUsage(ecDisqualified, 
		"Targeting file ought to have a .rom section", eDisqualified);
	Buffer romBuffer;
	allocateMore(romBuffer, rom -> size);
	bfd_get_section_contents(elffd, rom, &romBuffer[0], 0, rom -> size);

	// Initialize symbol processors, these processors will be used after
	// processing of symbol  table.
	std::map<std::string, BfdSymbolConsumer*> symbolProcessors;
	BfdOffsetConsumer wramSlowAddress(rom);
	symbolProcessors["__gba_slowwram_address"] = &wramSlowAddress;
	BfdOffsetConsumer wramFastAddress(rom);
	symbolProcessors["__gba_fastwram_address"] = &wramFastAddress;
	BfdOffsetConsumer wramSlowSize(rom);
	symbolProcessors["__gba_slowwram_size"] = &wramSlowSize;
	BfdOffsetConsumer wramFastSize(rom);
	symbolProcessors["__gba_fastwram_size"] = &wramFastSize;

	// Retrieve the symbol table from the ELF file.
	size_t numSymbolAlloc = bfd_get_symtab_upper_bound(elffd) / sizeof(asymbol*);
	std::vector<asymbol*> symbols(numSymbolAlloc);
	int numSymbols = bfd_canonicalize_symtab(elffd, symbols.data());

	// Attempt to retrieve critical symbols from the symbol table.
	for(int i = 0; i < numSymbols; ++ i) {
		std::string symbolName(symbols[i] -> name);
		if(symbolProcessors.count(symbolName) == 0) continue;
		symbolProcessors[symbolName] -> process(symbols[i]);
	}
	
	// Ensure the desired uploading symbols are in the .rom section.
	if(	wramSlowAddress.offset == 0 || wramFastAddress.offset == 0 ||
		wramSlowSize.offset == 0    || wramFastSize.offset == 0) 
		errorUsage(ecDisqualified, "Targeting file should have __gba_"
			"{slow,fast}wram_{address,size} to fill-in initialization "
			"information.", eDisqualified);

	// Attempt to write out the slow wram and fast wram data.
	// The loadable size of fast wram should be 0x080000, however they should
	// not occupy all space in fast wram the stack uses this space.
	appendLoadableSections(elffd, romBuffer, wramSlowAddress, wramSlowSize,
		wramSlowText, wramSlowData, rom -> vma, 0x040000);
	appendLoadableSections(elffd, romBuffer, wramFastAddress, wramFastSize,
		wramFastText, wramFastData, rom -> vma, 0x008000);

	// Attempt to create an output file to store the extracted ROM data.
	FILE* romfd = fopen(romFileName.c_str(), "wb");
	if(romfd == NULL) errorUsage(EBADF, "Cannot create ROM file on the system.");
	fwrite(romBuffer.data(), romBuffer.size(), 1, romfd);

	return 0;
}

